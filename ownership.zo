


/**
 *  This function takes ownership of var2 and is now responsible for it.
 */
function my_function2(take var2: Type2) {

	// var2 is dropped
}

/**
	my_function now owns var1
*/
function my_function(take var1: Type1) {
	let var2 = Type2.new()
	let var3 = Type2.new()

	// Extract the sub_field variable and own it
	// also, var5 is freed

	// I can do that here !
	var2.do_something()

	// var2 is no longer owned
	my_function2(give var2)
	// var2 is no longer usable past this point because it was dropped by my_function2

	// this is illegal, because var2 owns sub_field
	// the lesson being that you can only *give* what you *own*
	another_function(give var2.sub_field)

	let { sub_field } = take var5
	// var5 becomes unusable and is freed

	let sub_field_2 = take var6.sub_field2 // this is valid if var6.sub_field2 is of type Option,
		// which makes var6.sub_field2 = None
	another_function(give sub_field)

	// The queue might run these functions in any thread.
	let queue = TaskQueue.new(async (take t: Type2) => {
		// do something with t.

		// t is freed.
	})

	queue.push(give var3)
	// var3 is no longer usable past this point

	// Problem : I don't know if this closure will be called several times in parallel,
	// yet var4 is not particularly protected against concurrent access. There should
	// be some lock mechanic here, and it may affect the closure's type.
	task.schedule(() => {
		// var4 is taken

		var4.do_something()
		// var4 is not freed, it will be once the closure is freed.
	})
	// var4 is no longer usable past this point

	// var1 is freed
}
