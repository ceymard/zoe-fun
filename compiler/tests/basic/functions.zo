fn main() -> void { }
fn test@[$T](a: $T) -> { }

var a = fn (a: String = "") -> String { a }

# maybe a is typed
#(?
  (decl:var a
    (fndef
      (signature
        (lst)
        (lst (: a (infer)) (: b (infer)) )
        (infer)
      )
      (+ a c)
    )
  )
#)
var a = fn (a, b) => a + c

#(?
  (decl:fn
    ba
    (fndef
      (signature
        (lst $T $U)
        (lst (: a String) (: b $T))
        $U
      )
      (block
        (return (. a b))
      )
    )
  )
#)
fn ba@<$T, $U>(a: String, b: $T) -> $U { return a.b }

#(?
  (decl-var (= b
    (fndef
      (signature
        (lst $T $U)
        (lst (: a String) (: b $T))
        (infer)
      )
      (block
        (@ toto $U)
      )
    )
  ))
#)
var b = fn @[$T, $U](a: String, b: $T) => toto@$U

var map = fn @[$T, $U](a: Iterable<$T>, func: fn (arg: $T) -> $U) -> Slice<$U> {
  var res = Slice::create@$U(a.length ?? 0)
  for var item in a {
    yield func(item)
  }
}

#(?
  (call
    (. a map)
    (fndef
      (signature
        (lst)
        (lst (: a (infer)))
        (infer)
      )
      (block
        (return a)
      )
    )
  )
#)
a.map(fn (a) => a)


#(?
  (call c (lst a, b))
#)
c(a, b)