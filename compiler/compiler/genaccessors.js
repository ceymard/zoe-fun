#!/usr/bin/env node
const fs = require('fs')

const input = fs.readFileSync('./nodes.go', 'utf-8')

const re_type = /type (\w+) struct \{\s*NodeBase\s*([^\}]+)\}/g
const re_prop = /(\w+)\s+((?:\[\])?\*?\w+)/g

const names = []

console.log(`// Code generated by a lame .js file, DO NOT EDIT.

package zoe

import "io"
`)

var match, pmatch
while (match = re_type.exec(input)) {
  const [_, type, src] = match
  if (type === 'NodeBase') continue
  const finalsrc = src.replace(/\/\/[^\n]*\n/g, '')
  const lower = type.replace(/[A-Z]/g, m => '-' + m.toLowerCase()).slice(1)

  const fields = []

  console.log(`\nfunc (t *Token) Create${type}() *${type} {
  res := &${type}{}
  res.ExtendPosition(t)
  return res
}`)

  while (pmatch = re_prop.exec(finalsrc)) {
    const [_, name, proptype] = pmatch
    if (!proptype.includes('*') && !proptype.includes('Node')) continue

    const is_list = proptype.includes('[]')
    fields.push({name, type: proptype, is_list: is_list})

    if (is_list) {
      var lsttype = proptype.replace('[]', '')
      if (proptype === '[]Node') {
        console.log(`\nfunc (r *${type}) Add${name}(other ...${lsttype}) *${type} {
  for _, c := range other {
    if fragment, ok := c.(*Fragment); ok {
      for _, c2 := range fragment.Children {
        r.${name} = append(r.${name}, c2)
      }
    } else {
      r.${name} = append(r.${name}, c)
    }
    r.ExtendPosition(c)
  }
  return r
}`)
      } else {
        console.log(`\nfunc (r *${type}) Add${name}(other ...${lsttype}) *${type} {
  for _, c := range other {
    r.${name} = append(r.${name}, c)
    r.ExtendPosition(c)
  }
  return r
}`)
      }

    } else {
      console.log(`\nfunc (r *${type}) Set${name}(other ${proptype}) *${type} {
  r.${name} = other
  r.ExtendPosition(other)
  return r
}`)
    }
    // console.log(type, name, proptype, is_list)
  }

  if (fields.length) {

    console.log(`\nfunc (r *${type}) Dump(w io.Writer) {
  w.Write([]byte("(${lower}"))${fields.map(f => {
  if (f.is_list) {
    return `
  for _, c := range r.${f.name} {
    w.Write([]byte(" "))
    c.Dump(w)
  }`
  } else {
    return `
  w.Write([]byte(" "))
  r.${f.name}.Dump(w)`
  }
}).join('')}
  w.Write([]byte(")"))
}`)
  } else {
    console.log(`\nfunc (r *${type}) Dump(w io.Writer) {
  w.Write([]byte(r.GetText()))
}`)
  }

}
