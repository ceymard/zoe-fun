#!/usr/bin/env node
const fs = require('fs')

const input = fs.readFileSync('./nodes.go', 'utf-8')

const re_type = /type (\w+) struct \{\s*NodeBase\s*([^\}]+)\}/g
const re_prop = /(\w+)\s+((?:\[\])?\*?\w+)/g

console.log(`// Code generated by a lame .js file, DO NOT EDIT.

package zoe
`)

var match, pmatch
while (match = re_type.exec(input)) {
  const [_, type, src] = match
  if (type === 'NodeBase') continue
  const finalsrc = src.replace(/\/\/[^\n]*\n/g, '')

  console.log(`\nfunc (t *Token) Create${type}() *${type} {
  res := &${type}{}
  res.ExtendPosition(t)
  return res
}`)

  while (pmatch = re_prop.exec(finalsrc)) {
    const [_, name, proptype] = pmatch
    if (!proptype.includes('*') && !proptype.includes('Node')) continue

    const is_list = proptype.includes('[]')

    if (is_list) {
      var lsttype = proptype.replace('[]', '')
      if (proptype === '[]Node') {
        console.log(`\nfunc (r *${type}) Add${name}(other ...${lsttype}) *${type} {
  for _, c := range other {
    if fragment, ok := c.(*Fragment); ok {
      for _, c2 := range fragment.Children {
        r.${name} = append(r.${name}, c2)
      }
    } else {
      r.${name} = append(r.${name}, c)
    }
    r.ExtendPosition(c)
  }
  return r
}`)
      } else {
        console.log(`\nfunc (r *${type}) Add${name}(other ...${lsttype}) *${type} {
  for _, c := range other {
    r.${name} = append(r.${name}, c)
    r.ExtendPosition(c)
  }
  return r
}`)
      }

    } else {
      console.log(`\nfunc (r *${type}) Set${name}(other ${proptype}) *${type} {
  r.${name} = other
  r.ExtendPosition(other)
  return r
}`)
    }

    // console.log(type, name, proptype, is_list)
  }

}
