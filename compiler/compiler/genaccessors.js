#!/usr/bin/env node
const fs = require('fs')
const path = require('path')

const input = fs.readFileSync(path.join(__dirname, './nodes.go'), 'utf-8')

const re_type = /type (\w+) struct \{\s*NodeBase\s*([^\}]+)\}/g
const re_prop = /(\w+)\s+((?:\[\])?\*?\w+)/g

const names = []

console.log(`// Code generated by a lame .js file, DO NOT EDIT.

package zoe

import "io"
`)

var match, pmatch
while (match = re_type.exec(input)) {
  const [_, type, src] = match
  if (type === 'NodeBase') continue
  const finalsrc = src.replace(/\/\/[^\n]*\n/g, '')
  const lower = type.replace(/[A-Z]/g, m => '-' + m.toLowerCase()).slice(1)

  const fields = []

  while (pmatch = re_prop.exec(finalsrc)) {
    const [_, name, proptype] = pmatch
    if (!proptype.includes('*') && !proptype.includes('Node')) continue

    const is_list = proptype.includes('[]')
    fields.push({name, type: proptype, is_list: is_list})

    if (is_list) {
      var lsttype = proptype.replace('[]', '')
      if (proptype === '[]Node') {
        console.log(`\nfunc (r *${type}) Add${name}(other ...${lsttype}) *${type} {
  for _, c := range other {
    if fragment, ok := c.(*Fragment); ok {
      for _, c2 := range fragment.Children {
        r.${name} = append(r.${name}, c2)
      }
    } else {
      r.${name} = append(r.${name}, c)
    }
    r.ExtendPosition(c)
  }
  return r
}`)
      } else {
        console.log(`\nfunc (r *${type}) Add${name}(other ...${lsttype}) *${type} {
  for _, c := range other {
    r.${name} = append(r.${name}, c)
    r.ExtendPosition(c)
  }
  return r
}`)
      }

    } else {
      console.log(`\nfunc (r *${type}) Set${name}(other ${proptype}) *${type} {
  r.${name} = other
  r.ExtendPosition(other)
  return r
}`)
    }
    // console.log(type, name, proptype, is_list)
  }

  console.log(`\nfunc (p *Position) Create${type}() *${type} {
  res := &${type}{}
  res.ExtendPosition(p)
${fields.length ? fields.filter(f => !f.is_list && f.type !== 'Node').map(f => `  res.${f.name} = p.Create${f.type.slice(1)}()`).join('\n'): ''}
  return res
}`)

  console.log(`\nfunc (t *Token) Create${type}() *${type} {
  return (&t.Position).Create${type}()
}`)

  if (fields.length) {

    console.log(`\nfunc (r *${type}) Dump(w io.Writer) {
  w.Write([]byte(${
    lower === 'operation' ? '"(" + tokstr[r.TokenKind]' :
    lower === 'tuple' ? '"("' :
    lower === 'block' ? '"{"' :
    '"(' + lower + '"'
}))${fields.map(f => {
  if (f.is_list) {
    return `
  for _, c := range r.${f.name} {
    w.Write([]byte(" "))
    c.Dump(w)
  }`
  } else {
    return `
  if r.${f.name} != nil {
    w.Write([]byte(" "))
    r.${f.name}.Dump(w)
  }`
  }
}).join('')}
  w.Write([]byte("${
    lower === 'tuple' ? ')' :
    lower === 'block' ? '}' :
    ')'
  }"))
}`)
  } else {
    console.log(`\nfunc (r *${type}) Dump(w io.Writer) {
  w.Write([]byte(r.GetText()))
}`)
  }

}
