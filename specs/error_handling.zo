#(
  Zoe uses error by values.
  Errors are handled specially by the compiler.
#)

# Errors need to keep informations about other errors as well
type ErrorLocation is struct (
  filename: String = $.vars.current_file
  line: Size = $.vars.current_line
  column: Size = $.vars.current_column
  prev: *ErrorLocation | null
)

# somewhere, in the compiler
type Error is struct (
  message: String
  payload: any
  location *ErrorLocation
)
implements {

  wrap(err *Error) -> *Error {
    err.wrapped = this # this is always a pointer
    return err
  }

}

type FileError is Error + struct (
  filename String
)

# The compiler knows that FileError is an error, and thus allows for it to be used in try blocks
fn test() -> Int32 | Error {
  if some_condition {
    return 32
  }
  return os::FileError(message = 'Something happened', filename = 'Yes')
}

# error is like any, except it's only error types
fn test2() -> SomeResult | Error {
  var te = try test() catch te.wrap(FileError('mais naan'))

  var val = switch typeof te
    | Error | FileError => return te
    else 42

  if te is Error || te is FileError {
    return te
  }
  # or
  var te = try test() catch (err) {
    return err.wrap(SomeError('yo.', field = 'doing stuff', other_info = 3432))
  }

  # try catch with a block is not implemented because we want to force the hand
  # of the programmer to explicitely handle errors when they happen
}